ApexLegendsとは
	単一種類
	
	+インストールパス:文字列
	+ApexLegendsインストールパス:文字列
	
	+初期ビデオコンフィグ:辞書
	+初期起動引数:文字列
	
	+コンフィグフォルダー:文字列=「[プロファイルフォルダ]Saved Games\Respawn\Apex\local\」
	+プロファイルコンフィグフォルダー:文字列=「[プロファイルフォルダ]Saved Games\Respawn\Apex\profile\」
	
	はじめの手順
		監視有効=×
		プロセス起動中=×
	終わり
	
	起動準備中という属性
		取得する手順
			起動処理中を返す
		終わり
	終わり
	
	終了処理中という属性
		取得する手順
			監視終了処理実行中を返す
		終わり
	終わり
	
	プレイ中という属性
		取得する手順
			監視有効を返す
		終わり
	終わり
	
	起動引数という属性
		取得する手順
			起動引数取得したものを返す
		終わり
	終わり
	
	〈【プラットフォーム:文字列】から〉起動引数取得する手順:文字列
		// EA app
		例外監視
			/*【フォルダー:文字列】=「C:\Users\[ウィンドウズのユーザ名]\AppData\Local\Electronic Arts\EA Desktop\」
			【テレメトリー:辞書】=[「[フォルダー]telemetry.ini」から「UTF-8」で読み込んだもの]を辞書化したもの
			// telemetry.ini にIDの項目が存在する場合はそこから取得する
			もしテレメトリーに「token」が存在するなら
				【ユーザーデータ:辞書】=[「[フォルダー]user_[テレメトリー(「token」)].ini」から「UTF-8」で読み込んだもの]を辞書化したもの
				
			そうでなければ
				【ユーザーデータファイル一覧】=空の配列
				「[フォルダー]」のファイルの一覧を【ファイル】へそれぞれ繰り返す
					もしファイルが「user_」で始まるかつファイルの拡張子だけが「ini」なら
						ユーザーデータファイル一覧へファイルを追加する
					もし終わり
				繰り返し終わり
				
			もし終わり
			ユーザーデータ(「user.gamecommandline.origin.ofr.50.0002694」)を返す*/
		発生した場合
			「起動引数の読み込みに失敗しました。[改行][改行][エラーのメッセージ]」を「中止アイコン」で表示する
			「」を返す
		監視終わり
	終わり
	
	-ビルドデータ:文字列
	ビルドという属性
		取得する手順
			ビルドデータを返す
		終わり
	終わり
	
	-バージョンデータ:文字列
	バージョンという属性
		取得する手順
			バージョンデータを返す
		終わり
	終わり
	
	インストール先一覧という属性
		取得する手順
			{0}でインストール先一覧取得したものを返す
		終わり
	終わり
	
	自分で【値】を【変換先:文字列】へ視野角変換する手順
		変換先について分岐
		「ゲーム内」の場合
			70+(値-1)/0.01375を返す
		「設定値」の場合
			1+(値-70)*0.01375を返す
		その他の場合
			「不正な変換先です。」というエラーを発生させる
		分岐終わり
	終わり
	
	【プラットフォーム:配列】でインストール先一覧取得する手順:配列
		【一覧】=空の配列
		【プラットフォーム番号一覧:配列】=プラットフォーム
		
		もしプラットフォームが無ならプラットフォーム番号一覧={0}
		そうでなければプラットフォーム番号一覧=プラットフォーム
		もしプラットフォーム番号一覧が「{0}」ならプラットフォーム番号一覧={「Steam」,「EA app」}
		
		【インストール先】
		プラットフォーム番号一覧を【プラットフォーム番号】へそれぞれ繰り返す
			インストール先=プラットフォーム番号でインストール先取得したもの
			もしインストール先というフォルダが存在するなら一覧へインストール先を追加する
		繰り返し終わり
		一覧を返す
	終わり
	
	【プラットフォーム】でインストール先取得する手順:文字列
		【パス】=「」
		【インストール先】=「」
		プラットフォーム=「[プラットフォーム]」
		プラットフォームについて分岐
		「Steam」の場合 // Steam
			例外監視
			// レジストリーからSteamのインストール先を取得する
			【Steamパス】=Steamのインストール先
			// 取得したインストール先とライブラリーフォルダーのファイルが存在する場合、インストール先一覧に加える
			もし(Steamパスというフォルダが存在する)かつ(「[Steamパス]\steamapps\libraryfolders.vdf」というファイルが存在する)なら
				【ファイル】=「[Steamパス]\steamapps\libraryfolders.vdf」から「UTF-8」で読み込んだもの
				【ライブラリー】=ファイルをVDF形式として読み取ったものをJSON形式として読み取ったもの
				ライブラリー(「libraryfolders」)の見出しを【番号】へそれぞれ繰り返す
					ライブラリー(「libraryfolders」)(番号)(「apps」)の見出しを【AppID】へそれぞれ繰り返す
						もしAppIDが「1172470」なら
							パス=[ライブラリー(「libraryfolders」)(番号)(「path」)]&「\steamapps\common\Apex Legends」
							もしパスというフォルダが存在するなら
								もしパスが「\」で終わらないならパス=パス&「\」
								インストール先=「」&パス
							もし終わり
						もし終わり
					繰り返し終わり
				繰り返し終わり
			もし終わり
			発生した場合
				エラーのメッセージを「エラー」としてデバッグログへ出力する
				インストール先=無
			監視終わり
			
		「EA app」の場合 // EA app (Origin)
			例外監視
			// レジストリーからApex Legendsのインストール先を取得する
			パス=レジストリから「HKEY_LOCAL_MACHINE\SOFTWARE\Respawn\Apex\Install Dir」を取得したもの
			// 取得したインストール先フォルダーが存在する場合、インストール先一覧に加える
			もしパスというフォルダが存在するなら
				もしパスが「\」で終わらないならパス=パス&「\」
				インストール先=「」&パス
			もし終わり
			発生した場合
				エラーのメッセージを「エラー」としてデバッグログへ出力する
				インストール先=無
			監視終わり
			
		分岐終わり
		
		インストール先を返す
	終わり
	
	自分で【設定:配列】へ解像度変更する手順
		もし「[コンフィグフォルダー]videoconfig.txt」というファイルが存在するなら
			ビデオコンフィグ変更=○
			[言語管理器で「InPlay.Log.StartEditingVideoConfig」を取得したもの]をログ出力する
			
			// ビデオコンフィグのバックアップを作成
			//「[コンフィグフォルダー]videoconfig.txt」を「[アプリのコンフィグフォルダー]Backup\VideoConfig\videoconfig_[今を「yyyyMMdd-HHmmss」に整えたもの].txt」へコピーする
			
			// ビデオコンフィグを読み込む
			【コンフィグファイル】=「[コンフィグフォルダー]videoconfig.txt」から読み込んだもの
			「ビデオコンフィグ: [コンフィグファイルをVDF形式として読み取ったもの]」をデバッグログへ出力する
			【コンフィグ】=[コンフィグファイルをVDF形式として読み取ったもの]をJSON形式として読み取ったもの
			
			初期ビデオコンフィグ=[コンフィグファイルをVDF形式として読み取ったもの]をJSON形式として読み取ったもの
			
			コンフィグ(「VideoConfig」)(「setting.defaultres」)=「[設定(1)]」
			コンフィグ(「VideoConfig」)(「setting.defaultresheight」)=「[設定(2)]」
			
			コンフィグ(「VideoConfig」)(「setting.fullscreen」)=「1」
			コンフィグ(「VideoConfig」)(「setting.nowindowborder」)=「0」
			
			// ビデオコンフィグファイルを削除する
			「[コンフィグフォルダー]videoconfig.txt」へ「標準」というファイル属性を設定する
			「[コンフィグフォルダー]videoconfig.txt」を削除する
			// 編集したビデオコンフィグをファイルに保存する
			コンフィグをJSON形式として書き出したものをVDF形式として書き出したものを「[コンフィグフォルダー]videoconfig.txt」へ保存する
			// ファイルを読み取り専用にする
			//「[コンフィグフォルダー]videoconfig.txt」へ「読み取り専用」というファイル属性を設定する
			○を返す
			
		そうでなければ
			ビデオコンフィグ変更=×
			×を返す
			
		もし終わり
	終わり
	
	
	+エラー一覧:辞書={
		「0」={「起動処理時にエラーが発生しました。」},
		「1」={「プロファイルの読み込みに失敗しました。」},
		「2」={「ディスプレイ設定の変更に失敗しました。」},
		「3」={「Apex Legends の起動時にエラーが発生しました。」},
		「4」={「Apex Legends を起動できませんでした。Apex Legends がインストールされていない可能性があります。」},
		「5」={「Apex Legends のプロセスを時間内に取得できませんでした。」},
		「6」={「Alt+Enter 自動押下の待機時にエラーが発生しました。」},
		「7」={「Alt+Enter 自動押下の実行時にエラーが発生しました。」},
		「8」={「Apex Legends の起動に失敗しました。」},
		「9」={「起動引数の変更失敗」},
		「10」={「ビデオコンフィグの変更に失敗しました。」},
		「11」={「プロセスの待機がキャンセルされました。」},
		「12」={「インストール先の取得に失敗しました。」},
		「13」={「コンフィグの取得に失敗しました。」},
		「14」={「コンフィグの作成に失敗しました。」},
		「15」={「コンフィグの復元に失敗しました。」},
		「16」={「ビデオコンフィグの取得に失敗しました。」},
		「17」={「ビデオコンフィグの作成に失敗しました。」},
		「18」={「ビデオコンフィグの復元に失敗しました。」},
		「19」={「プロファイルコンフィグの取得に失敗しました。」},
		「20」={「プロファイルコンフィグの作成に失敗しました。」},
		「21」={「プロファイルコンフィグの復元に失敗しました。」},
		「22」={「EA app のコンフィグから起動引数を削除できませんでした。」}
	}
	言語読み込む手順
		// エラーメッセージ
		エラー一覧の見出しを【番号】へそれぞれ繰り返す
			エラー一覧(番号)={[言語管理器で「InPlay.Error.[番号]」を取得したもの]}
		繰り返し終わり
	終わり
	
	
	+ステータス番号
	-プロファイル名:文字列
	+プロファイル:プロファイル
	-プロファイルID:文字列
	
	-起動処理スレッド:スレッド
	-起動処理オプション:配列
	自分を【ID:文字列】で〈【オプション:配列】として〉起動する手順
		ステータス番号=0
		
		言語読み込む
		
		もしオプションが無なら起動処理オプション=空の配列
		そうでなければ起動処理オプション=オプション
		
		【起動処理結果】
		
		起動中パネル表示する
		// 各テキストの初期化
		メイン画面の起動中パネルのプレイ処理状況=言語管理器で「InPlay.Status.ProcessingStartup」を取得したもの
		メイン画面の起動中パネルのCPU使用率ラベルの内容=「-----」
		メイン画面の起動中パネルのGPU使用率ラベルの内容=「-----」
		メイン画面の起動中パネルのプロファイル名ラベルの内容=「」
		メイン画面の起動中パネルのPIDラベルの内容=「-----」
		メイン画面の起動中パネルのカーソル状態ラベルの内容=「-----」
		メイン画面の起動中パネルのビルドラベルの内容=「-----」
		メイン画面の起動中パネルのバージョンラベルの内容=「-----」
		メイン画面の起動中パネルのログテキストの内容=「」
		
		起動処理スレッドというスレッドを作る
		起動処理スレッドのバックグラウンド=○
		起動処理スレッドで『
		
		例外監視
			// ニュースの更新を停止する
			メイン画面のメインメニューパネルのニュース定期更新有効=×
			プロファイルID=ID
			プロファイルIDで起動処理開始する
		発生した場合
			// アカウント切り替え処理時に表示される画面を閉じる
			処理画面を閉じる
			
			// エラーが発生した場合は起動中パネルを閉じて、エラーダイアログを表示する
			もし起動処理オプションから「ショートカット」を完全一致で探したものの個数が1以上でないなら監視終了する
			
			[言語管理器で「InPlay.ErrorLog.StartupProcessFailed」を{[ステータス番号],[エラー一覧(「[ステータス番号]」)(1)],[エラーのメッセージ]}として取得したもの]を「エラー」としてログ出力する
			[言語管理器で「InPlay.Error.StartupProcessFailed」を{[ステータス番号],[エラー一覧(「[ステータス番号]」)(1)],[エラーのメッセージ]}として取得したもの]を「警告アイコン」で表示する
			
			// 直接プロファイルを起動した場合はアプリを終了する
			もし起動処理オプションから「ショートカット」を完全一致で探したものの個数が1以上なら
				監視終了する
			もし終わり
			
			起動処理中=×
			
			起動中パネル隠す
		監視終わり
		
		』を実行する
	終わり
	
	-ビデオコンフィグ変更:真偽値
	-起動処理中:真偽値
	-メインディスプレイ:文字列
	自分を〈【ID:文字列】で〉起動処理開始する手順
		ステータス番号=0
		もし起動処理中が○なら
			[言語管理器で「InPlay.Error.Game_StartupProcessingIsAlreadyInProgress」を取得したもの]というエラーを発生させる
		もし終わり
		
		「起動処理開始」をデバッグログへ出力する
		// プロファイルを読み込む
		プロファイル読み込む
		
		メイン画面の起動中パネルの起動引数テキストの内容=「[プロファイルの起動引数]」
		
		// Alt+Enter 自動押下処理の画像比較用タイトル画面画像を取得する
		もし(プロファイルのゲーム解像度変更が○)かつ(プロファイルのAltEnter自動押下が○)なら
			[言語管理器で「InPlay.Log.RetrievingLatestTitleScreenImage」を取得したもの]をログ出力する
			最新タイトル画面取得結果=最新タイトル画面取得したもの
			もし最新タイトル画面取得結果(1)が×なら[言語管理器で「InPlay.Log.RetrievingLatestTitleScreenImage_Failed」を{[最新タイトル画面取得結果(2)]}として取得したもの]をログ出力する
			そうでなければ[言語管理器で「InPlay.Log.RetrievingLatestTitleScreenImage_Succeeded」を{[最新タイトル画面取得結果(2)]}として取得したもの]をログ出力する
		もし終わり
		
		起動処理中=○
		待機キャンセル=×
		
		プレイ開始日時=無
		プレイ終了日時=無
		
		初期ビデオコンフィグ=無
		
		【ディスプレイ:画面領域】
		【ディスプレイ番号】を1から1ずつ増やしながら10まで繰り返す
			ディスプレイ=画面の[ディスプレイ番号]番目を取得したもの
			もしディスプレイのメインが○なら
				メインディスプレイ=ディスプレイの名前
				繰り返しから抜け出す
			もし終わり
		繰り返し終わり
		
		インストールパス取得する
		
		プロファイルのApexLegendsプラットフォームについて分岐
		「Steam」の場合
			
		「EA app」の場合
			// 実験的機能:account_switcher_eaapp_240928
			// アカウント切り替え機能が有効の場合のみ切り替え処理を実行する
			もし実験的機能管理器の機能一覧(「account_switcher_eaapp_240928」)(「有効」)が○なら
				// アカウントを切り替える
				【アカウント切り替え結果:真偽値】=×
				もしプロファイルのEAappアカウントが0でないかつプロファイルのEAappアカウントが無でないなら
					もしプロファイルのEAappアカウントがEAappの現在ユーザーIDなら
						「既に選択されたアカウント [EAappでプロファイルのEAappアカウントからアカウント名取得したもの] (ID: [プロファイルのEAappアカウント]) にログインしているため、アカウントの切り替えは実行されません。」をログ出力する
						
					そうでなければ
						「アカウントを切り替え」をログ出力する
						「- 切り替え先アカウント: [EAappでプロファイルのEAappアカウントからアカウント名取得したもの]」をログ出力する
						処理画面を表示する
						アカウント切り替え結果=EAappでプロファイルのEAappアカウントへアカウント切り替える
						もしアカウント切り替え結果が×なら「アカウントの切り替えに失敗しました。」というエラーを発生させる
						そうでなければ「完了」をログ出力する
						8秒待つ
						
					もし終わり
				もし終わり
			もし終わり
			
			// EA app で設定されている起動引数を削除する
			デフォルトコンフィグリセットする
		分岐終わり
		
		// コンフィグ (settings.cfg) を取得/作成する
		1としてコンフィグ取得する
		
		// プロファイルコンフィグ (profile.cfg) を取得/作成する
		2としてコンフィグ取得する
		
		// ビデオコンフィグ (videoconfig.txt) を取得/作成する
		3としてコンフィグ取得する
		
		// ビデオコンフィグを編集する (解像度の変更が有効の場合のみ)
		ビデオコンフィグ編集する
		
		// システム(PC自体)のディスプレイ解像度を変更する (システムの解像度変更が有効の場合のみ)
		システムディスプレイ解像度変更する
		
		// Apex Legends を起動する
		プロセス起動する
		プロセス起動待機する
		
		自分を監視開始する
		
		AltEnter自動押下実行する
		
		起動処理中=×
		
		もし(インストールパスというファイルが存在する)かつ(Apexプロセスの起動中が○)なら
			{○}を返す
			
		そうでなければ
			{×,「Apex Legends の起動に失敗しました。設定に誤りがないか確認してからもう一度お試しください。」,8}を返す
			
		もし終わり
	終わり
	
	////////// 起動処理の手順 //////////
	ビルド情報取得する手順
		// インストール先フォルダーを取得する
		【インストール先:文字列】=プロファイルのApexLegendsバイナリーパスのフォルダだけ
		
		// インストールされているゲームのビルドとバージョンを取得
		[言語管理器で「InPlay.Log.GettingDetailsOfInstalledGames」を取得したもの]をログ出力する
		
		もし「[インストール先]build.txt」が存在するならビルドデータ=テキストファイル読取器:「[インストール先]build.txt」から「UTF-8」で読み取ったもの
		そうでなければビルドデータ=「取得できませんでした」
		もし「[インストール先]gameversion.txt」が存在するならバージョンデータ=テキストファイル読取器:「[インストール先]gameversion.txt」から「UTF-8」で読み取ったもの
		そうでなければバージョンデータ=「取得できませんでした」
		
		メイン画面の起動中パネルのビルドラベルの内容=ビルド
		メイン画面の起動中パネルのバージョンラベルの内容=バージョン
		
		[言語管理器で「InPlay.Log.Done」を取得したもの]をログ出力する
	終わり
	
	+実行ファイル名:文字列
	プロファイル読み込む手順
		ステータス番号=1
		
		[言語管理器で「InPlay.Log.LoadingProfile」を取得したもの]をログ出力する
		
		// プロファイルを読み込む
		もしプロファイルIDが無でないなら
			もしプロファイル管理器のプロファイルテーブルにプロファイルIDが存在するなら
				プロファイル=プロファイル管理器のプロファイルテーブル(プロファイルID)
				
			そうでなければ
				[言語管理器で「InPlay.Error.Profile_SpecifiedProfileNotFound」を{プロファイルID}として取得したもの]というエラーを発生させる
				
			もし終わり
			
		// プロファイル名が指定されていない場合は「Default」を読み込む
		そうでなければ
			プロファイル=プロファイル管理器のプロファイルテーブル(「Default」)
			
		もし終わり
		
		メイン画面の起動中パネルのプロファイル名ラベルの内容=プロファイルの名前
		
		もしプロファイルの起動引数が「-anticheat_settings=SettingsDX12.json」を含むなら
			実行ファイル名=「r5apex_dx12」
			
		そうでなければ
			実行ファイル名=「r5apex」
			
		もし終わり
		
		[言語管理器で「InPlay.Log.Done」を取得したもの]をログ出力する
		
		
		// プロファイルからアカウントのIDを取得
		/*「ログイン中のアカウントを取得」をログ出力する
		
		【アカウントID】=プロファイルのアカウント
		もしアカウントIDが「-1」なら
			もしプロファイルのApexLegendsプラットフォームが「Steam」なら「ログイン中のアカウントを取得できませんでした。[改行]Steam クライアントからログアウトしている可能性があります。」というエラーを発生させる
			他でもしプロファイルのApexLegendsプラットフォームが「EA app」なら「ログイン中のアカウントを取得できませんでした。[改行]EA app からログアウトしている可能性があります。」というエラーを発生させる
		もし終わり
		
		// 使用するコンフィグとビデオコンフィグのファイル名を設定する
		コンフィグファイル名=「[プロファイルのID]_[プロファイルのApexLegendsプラットフォームで「 」を無に置換したもの]_[アカウントID].cfg」
		ビデオコンフィグファイル名=「[プロファイルのID]_[プロファイルのApexLegendsプラットフォームで「 」を無に置換したもの]_[アカウントID].txt」
		プロファイルコンフィグファイル名=「[プロファイルのID]_[プロファイルのApexLegendsプラットフォームで「 」を無に置換したもの]_[アカウントID].cfg」*/
		
		// 使用するコンフィグとビデオコンフィグのファイル名を設定する
		コンフィグファイル名=「[プロファイルのID]_[プロファイルのApexLegendsプラットフォームで「 」を無に置換したもの].cfg」
		ビデオコンフィグファイル名=「[プロファイルのID]_[プロファイルのApexLegendsプラットフォームで「 」を無に置換したもの].txt」
		プロファイルコンフィグファイル名=「[プロファイルのID]_[プロファイルのApexLegendsプラットフォームで「 」を無に置換したもの].cfg」
		
		[言語管理器で「InPlay.Log.Done」を取得したもの]をログ出力する
	終わり
	
	インストールパス取得する手順
		ステータス番号=12
		// Apex Legends の実行ファイルのパスを取得する 取得できなければエラー
		[言語管理器で「InPlay.Log.GettingGameInstallationLocation」を取得したもの]をログ出力する
		インストールパス=プロファイルのApexLegendsバイナリーパス
		もしインストールパスというファイルが存在するなら
			「- [言語管理器で「InPlay.Log.Path」を取得したもの]: [インストールパス]」をログ出力する
			// autoexec を生成(コピー)する
			プロファイルでコンフィグファイル生成する
			もしプロファイルの起動引数が「+exec」を含むなら
				「[アプリのコンフィグフォルダー]Profile\AutoExecute\autoexec_[プロファイルのID].cfg」を「[インストールパスのフォルダだけ]cfg\autoexec_[プロファイルのID].cfg」へコピーする
				「- 」&[言語管理器で「InPlay.Log.GenerateAutoexec」を{「[インストールパスのフォルダだけ]cfg\autoexec_[プロファイルのID].cfg」}として取得したもの]をログ出力する
			もし終わり

		そうでなければ
			[言語管理器で「InPlay.Error.InstallPath_FileNotFound」を{[インストールパス]}として取得したもの]というエラーを発生させる
			
		もし終わり
	終わり
	
	デフォルトコンフィグリセットする手順
		ステータス番号=22
		
		// EA app でログイン中のユーザーIDを取得できた場合はコンフィグの編集を試行する
		もしEAappの現在ユーザーIDが-1でないなら
			// EA app のコンフィグを読み込む
			例外監視
				EAappで1としてコンフィグ読み込む
			発生した場合
				[言語管理器で「InPlay.ErrorLog.EAappConfigEditingFailed_CouldNotLoadConfigFile」を{[EAappの現在ユーザーID]}として取得したもの]をログ出力する
				手順から抜け出す
			監視終わり
			
			例外監視
				もし[EAappのコンフィグ(「user.gamecommandline.origin.ofr.50.0002694」)]が「」でないなら
					【質問結果】=[言語管理器で「InPlay.Dialog.Game_DeleteStartupArgsInEAappProperties」を{[EAappのコンフィグ(「user.gamecommandline.origin.ofr.50.0002694」)]}として取得したもの]を「警告アイコン」にして「はいといいえ」で質問したもの
					もし質問結果が「はい」なら
						[言語管理器で「InPlay.Log.EAapp_ConfigEditing」を取得したもの]をログ出力する
						// EA app を終了させないとコンフィグの内容が上書きされてしまうので終了させる
						「- 」&[言語管理器で「InPlay.Log.EAapp_Close」を取得したもの]をログ出力する
						EAappを終了する
						「- 」&[言語管理器で「InPlay.Log.Done」を取得したもの]をログ出力する
						
						「- 」&[言語管理器で「InPlay.Log.DeleteStartupArgsInConfig」を取得したもの]をログ出力する
						// Apex Legends の起動引数を削除する
						EAappのコンフィグ(「user.gamecommandline.origin.ofr.50.0002694」)=「」
						// 編集したコンフィグを保存する
						EAappでコンフィグ保存する
						「- 」&[言語管理器で「InPlay.Log.Done」を取得したもの]をログ出力する
					もし終わり
				もし終わり
			発生した場合
				エラーのメッセージを「エラー」としてログ出力する
				[言語管理器で「InPlay.ErrorLog.EAappConfigEditingFailed_WithErrMsg」を{[エラーのメッセージ]}として取得したもの]をログ出力する
				手順から抜け出す
			監視終わり
		そうでなければ
			[言語管理器で「InPlay.ErrorLog.EAappConfigEditingFailed_CouldNotGetLoggedInUser」を取得したもの]をログ出力する
			手順から抜け出す
			
		もし終わり
	終わり
	
	-初期コンフィグ:辞書
	-コンフィグファイル:ファイル情報
	-コンフィグファイル名:文字列
	【対象:整数】としてコンフィグ取得する手順
		ステータス番号=13
		
		【保存ファイルパス:文字列】 // ゲームが読み込むファイルのパス
		【共通ファイルパス:文字列】 // 共通ファイルのバックアップのパス
		【固有ファイルパス:文字列】 // 固有ファイルのパス
		
		例外監視
			対象について分岐
			1の場合 // コンフィグ
				[言語管理器で「InPlay.Log.GetConfigFile」を{[言語管理器で「InPlay.Log.ConfigFile」を取得したもの]}として取得したもの]をログ出力する
				保存ファイルパス=「[コンフィグフォルダー]settings.cfg」 // ゲームが読み込むファイルのパス
				共通ファイルパス=「[アプリのコンフィグフォルダー]Backup\Config\settings.cfg」 // 共通ファイルのバックアップのパス
				固有ファイルパス=「[アプリのコンフィグフォルダー]Profile\Config\[コンフィグファイル名]」 // 固有ファイルのパス
			2の場合 // プロファイルコンフィグ
				[言語管理器で「InPlay.Log.GetConfigFile」を{[言語管理器で「InPlay.Log.ProfileConfigFile」を取得したもの]}として取得したもの]をログ出力する
				保存ファイルパス=「[プロファイルコンフィグフォルダー]profile.cfg」 // ゲームが読み込むファイルのパス
				共通ファイルパス=「[アプリのコンフィグフォルダー]Backup\ProfileConfig\profile.cfg」 // 共通ファイルのバックアップのパス
				固有ファイルパス=「[アプリのコンフィグフォルダー]Profile\ProfileConfig\[プロファイルコンフィグファイル名]」 // 固有ファイルのパス
			3の場合 // ビデオコンフィグ
				[言語管理器で「InPlay.Log.GetConfigFile」を{[言語管理器で「InPlay.Log.VideoConfigFile」を取得したもの]}として取得したもの]をログ出力する
				保存ファイルパス=「[コンフィグフォルダー]videoconfig.txt」 // ゲームが読み込むファイルのパス
				共通ファイルパス=「[アプリのコンフィグフォルダー]Backup\VideoConfig\videoconfig.txt」 // 共通ファイルのバックアップのパス
				固有ファイルパス=「[アプリのコンフィグフォルダー]Profile\VideoConfig\[ビデオコンフィグファイル名]」 // 固有ファイルのパス
			分岐終わり
			
			// プロファイル固有のコンフィグを読み込むための処理
			もし(プロファイルのコンフィグ指定が2)なら
				// プロファイル固有のコンフィグファイルが見つからない場合は作成(通常のコンフィグファイルをコピー)する
				もし固有ファイルパスが存在しないなら
					対象としてコンフィグ作成する
				もし終わり
				
				// 通常のコンフィグファイルの内容を取得する
				【コンフィグファイルデータ】=保存ファイルパスから読み込んだもの
				初期コンフィグ=[コンフィグファイルデータをVDF形式として読み取ったもの]をJSON形式として読み取ったもの
				
				// 通常のコンフィグファイルを避難させる (バックアップ)
				保存ファイルパスを共通ファイルパスへコピーする
				
				// ファイル属性をリセット
				共通ファイルパスへ「標準」というファイル属性を設定する
				保存ファイルパスへ「標準」というファイル属性を設定する
				
				// プロファイル固有のコンフィグファイルをコンフィグフォルダーへコピーする
				固有ファイルパスを保存ファイルパスへコピーする
			もし終わり
			
			// 読み取り専用が有効ならファイル属性へ読み取り専用を設定する
			もし(プロファイルのコンフィグ読み取り専用が○)なら
				保存ファイルパスへ「読み取り専用」というファイル属性を設定する
				
			そうでなければ
				保存ファイルパスへ「標準」というファイル属性を設定する
				
			もし終わり
			
			コンフィグファイル=ファイル情報(保存ファイルパス)を作ったもの
			
			[言語管理器で「InPlay.Log.Done」を取得したもの]をログ出力する
		発生した場合
			エラーのメッセージというエラーを発生させる
		監視終わり
	終わり
	
	【対象:整数】としてコンフィグ作成する手順
		ステータス番号=14
		
		【保存ファイルパス:文字列】 // ゲームが読み込むファイルのパス
		【共通ファイルパス:文字列】 // 共通ファイルのバックアップのパス
		【固有ファイルパス:文字列】 // 固有ファイルのパス
		【旧固有ファイルパス:文字列】 // アカウント切り替え機能実装前の固有ファイル
		
		例外監視
			対象について分岐
			1の場合 // コンフィグ
				[言語管理器で「InPlay.Log.CopyConfigFile」を{[言語管理器で「InPlay.Log.ConfigFile」を取得したもの]}として取得したもの]をログ出力する
				保存ファイルパス=「[コンフィグフォルダー]settings.cfg」 // ゲームが読み込むファイルのパス
				共通ファイルパス=「[アプリのコンフィグフォルダー]Backup\Config\settings.cfg」 // 共通ファイルのバックアップのパス
				固有ファイルパス=「[アプリのコンフィグフォルダー]Profile\Config\[コンフィグファイル名]」 // 固有ファイルのパス
				旧固有ファイルパス=「[アプリのコンフィグフォルダー]Profile\Config\[プロファイルのID].cfg」
			2の場合 // プロファイルコンフィグ
				[言語管理器で「InPlay.Log.CopyConfigFile」を{[言語管理器で「InPlay.Log.ProfileConfigFile」を取得したもの]}として取得したもの]をログ出力する
				保存ファイルパス=「[プロファイルコンフィグフォルダー]profile.cfg」 // ゲームが読み込むファイルのパス
				共通ファイルパス=「[アプリのコンフィグフォルダー]Backup\ProfileConfig\profile.cfg」 // 共通ファイルのバックアップのパス
				固有ファイルパス=「[アプリのコンフィグフォルダー]Profile\ProfileConfig\[プロファイルコンフィグファイル名]」 // 固有ファイルのパス
				旧固有ファイルパス=「[アプリのコンフィグフォルダー]Profile\ProfileConfig\[プロファイルのID].cfg」
			3の場合 // ビデオコンフィグ
				[言語管理器で「InPlay.Log.CopyConfigFile」を{[言語管理器で「InPlay.Log.VideoConfigFile」を取得したもの]}として取得したもの]をログ出力する
				保存ファイルパス=「[コンフィグフォルダー]videoconfig.txt」 // ゲームが読み込むファイルのパス
				共通ファイルパス=「[アプリのコンフィグフォルダー]Backup\VideoConfig\videoconfig.txt」 // 共通ファイルのバックアップのパス
				固有ファイルパス=「[アプリのコンフィグフォルダー]Profile\VideoConfig\[ビデオコンフィグファイル名]」 // 固有ファイルのパス
				旧固有ファイルパス=「[アプリのコンフィグフォルダー]Profile\VideoConfig\[プロファイルのID].txt」
			分岐終わり
			
			// アカウント切り替え機能実装前のファイルが存在する場合はそのファイルから移行する
			もし旧固有ファイルパスが存在するなら
				「- 」&[言語管理器で「InPlay.Log.TransferConfigFile_Path」を{旧固有ファイルパス,固有ファイルパス}として取得したもの]をログ出力する
				旧固有ファイルパスを固有ファイルパスへコピーする
				
			// そうでない場合は既存のファイルをコピーする
			そうでなければ
				「- 」&[言語管理器で「InPlay.Log.CopyConfigFile_Path」を{保存ファイルパス,固有ファイルパス}として取得したもの]をログ出力する
				保存ファイルパスを固有ファイルパスへコピーする
				
			もし終わり
			
			[言語管理器で「InPlay.Log.Done」を取得したもの]をログ出力する
		発生した場合
			エラーのメッセージというエラーを発生させる
		監視終わり
	終わり
	
	【対象:整数】としてコンフィグ復元する手順
		ステータス番号=15
		
		【保存ファイルパス:文字列】 // ゲームが読み込むファイルのパス
		【共通ファイルパス:文字列】 // 共通ファイルのバックアップのパス
		【固有ファイルパス:文字列】 // 固有ファイルのパス
		【コンフィグ種類:文字列】
		
		例外監視
			対象について分岐
			1の場合 // コンフィグ
				コンフィグ種類=[言語管理器で「InPlay.Log.ConfigFile」を取得したもの]
				[言語管理器で「InPlay.Log.CopyConfigFile」を{[言語管理器で「InPlay.Log.ConfigFile」を取得したもの]}として取得したもの]をログ出力する
				保存ファイルパス=「[コンフィグフォルダー]settings.cfg」 // ゲームが読み込むファイルのパス
				共通ファイルパス=「[アプリのコンフィグフォルダー]Backup\Config\settings.cfg」 // 共通ファイルのバックアップのパス
				固有ファイルパス=「[アプリのコンフィグフォルダー]Profile\Config\[コンフィグファイル名]」 // 固有ファイルのパス
			2の場合 // プロファイルコンフィグ
				コンフィグ種類=[言語管理器で「InPlay.Log.ProfileConfigFile」を取得したもの]
				[言語管理器で「InPlay.Log.CopyConfigFile」を{[言語管理器で「InPlay.Log.ProfileConfigFile」を取得したもの]}として取得したもの]をログ出力する
				保存ファイルパス=「[プロファイルコンフィグフォルダー]profile.cfg」 // ゲームが読み込むファイルのパス
				共通ファイルパス=「[アプリのコンフィグフォルダー]Backup\ProfileConfig\profile.cfg」 // 共通ファイルのバックアップのパス
				固有ファイルパス=「[アプリのコンフィグフォルダー]Profile\ProfileConfig\[プロファイルコンフィグファイル名]」 // 固有ファイルのパス
			3の場合 // ビデオコンフィグ
				コンフィグ種類=[言語管理器で「InPlay.Log.VideoConfigFile」を取得したもの]
				[言語管理器で「InPlay.Log.CopyConfigFile」を{[言語管理器で「InPlay.Log.VideoConfigFile」を取得したもの]}として取得したもの]をログ出力する
				保存ファイルパス=「[コンフィグフォルダー]videoconfig.txt」 // ゲームが読み込むファイルのパス
				共通ファイルパス=「[アプリのコンフィグフォルダー]Backup\VideoConfig\videoconfig.txt」 // 共通ファイルのバックアップのパス
				固有ファイルパス=「[アプリのコンフィグフォルダー]Profile\VideoConfig\[ビデオコンフィグファイル名]」 // 固有ファイルのパス
			分岐終わり
			
			もし(プロファイルのコンフィグ指定が2)かつ(固有ファイルパスが存在する)なら
				[言語管理器で「InPlay.Log.RestoreConfigFile」を{コンフィグ種類}として取得したもの]をログ出力する
				
				【元ファイル属性】
				
				// 元のファイル属性を取得する
				元ファイル属性=固有ファイルパスからファイル属性を取得したもの
				// ファイル属性を一時的にリセット
				固有ファイルパスへ「標準」というファイル属性を設定する
				
				// プロファイル固有のコンフィグファイルを保存する
				「- 」&[言語管理器で「InPlay.Log.SaveProfileSpecificConfigFile」を取得したもの]をログ出力する
				保存ファイルパスを固有ファイルパスへコピーする
				
				// ファイル属性を復元する
				固有ファイルパスへ元ファイル属性というファイル属性を設定する
				
				
				// 元のファイル属性を取得する
				元ファイル属性=保存ファイルパスからファイル属性を取得したもの
				// ファイル属性を一時的にリセット
				保存ファイルパスへ「標準」というファイル属性を設定する
				
				// バックアップしたコンフィグファイルをコンフィグフォルダーへコピーする
				「- 」&[言語管理器で「InPlay.Log.RestoreGlobalConfigFile」を取得したもの]をログ出力する
				共通ファイルパスを保存ファイルパスへコピーする
				
				// ファイル属性を復元する
				保存ファイルパスへ元ファイル属性というファイル属性を設定する
				
				[言語管理器で「InPlay.Log.Done」を取得したもの]をログ出力する
			もし終わり
		発生した場合
			エラーのメッセージというエラーを発生させる
		監視終わり
	終わり
	
	/*-初期プロファイルコンフィグ:辞書
	-プロファイルコンフィグファイル:ファイル情報
	-プロファイルコンフィグファイル名:文字列
	プロファイルコンフィグ取得する手順
		ステータス番号=19
		
		例外監視
			[言語管理器で「InPlay.Log.GetConfigFile」を{[言語管理器で「InPlay.Log.ProfileConfigFile」を取得したもの]}として取得したもの]をログ出力する
			
			// プロファイル固有のプロファイルコンフィグを読み込むための処理
			もし(プロファイルのプロファイルコンフィグ指定が2)なら
				// プロファイル固有のプロファイルコンフィグファイルが見つからない場合は作成(通常のプロファイルコンフィグファイルをコピー)する
				もし「[アプリのコンフィグフォルダー]Profile\ProfileConfig\[プロファイルコンフィグファイル名]」が存在しないなら
					プロファイルコンフィグ作成する
				もし終わり
				
				// 通常のプロファイルコンフィグファイルの内容を取得する
				【プロファイルコンフィグファイルデータ】=「[プロファイルコンフィグフォルダー]profile.cfg」から読み込んだもの
				初期プロファイルコンフィグ=[プロファイルコンフィグファイルデータをVDF形式として読み取ったもの]をJSON形式として読み取ったもの
				
				// 通常のプロファイルコンフィグファイルを避難させる (バックアップ)
				「[プロファイルコンフィグフォルダー]profile.cfg」を「[アプリのコンフィグフォルダー]Backup\ProfileConfig\profile.cfg」へコピーする
				
				// ファイル属性をリセット
				「[アプリのコンフィグフォルダー]Backup\ProfileConfig\profile.cfg」へ「標準」というファイル属性を設定する
				「[プロファイルコンフィグフォルダー]profile.cfg」へ「標準」というファイル属性を設定する
				
				// プロファイル固有のプロファイルコンフィグファイルをプロファイルコンフィグフォルダーへコピーする
				「[アプリのコンフィグフォルダー]Profile\ProfileConfig\[プロファイルコンフィグファイル名]」を「[プロファイルコンフィグフォルダー]profile.cfg」へコピーする
			もし終わり
			
			// 読み取り専用が有効ならファイル属性へ読み取り専用を設定する
			もし(プロファイルのプロファイルコンフィグ読み取り専用が○)なら
				「[プロファイルコンフィグフォルダー]profile.cfg」へ「読み取り専用」というファイル属性を設定する
				
			そうでなければ
				「[プロファイルコンフィグフォルダー]profile.cfg」へ「標準」というファイル属性を設定する
				
			もし終わり
			
			プロファイルコンフィグファイル=ファイル情報(「[プロファイルコンフィグフォルダー]profile.cfg」)を作ったもの
			
			[言語管理器で「InPlay.Log.Done」を取得したもの]をログ出力する
		発生した場合
			エラーのメッセージというエラーを発生させる
		監視終わり
	終わり
	
	プロファイルコンフィグ作成する手順
		ステータス番号=20
		
		例外監視
			// アカウント切り替え機能実装前のファイルが存在する場合はそのファイルから移行する
			もし「[アプリのコンフィグフォルダー]Profile\ProfileConfig\[プロファイルのID].cfg」が存在するなら
				「- 」&[言語管理器で「InPlay.Log.TransferConfigFile_Path」を{「[アプリのコンフィグフォルダー]Profile\ProfileConfig\[プロファイルのID].cfg」,「[アプリのコンフィグフォルダー]Profile\Config\[コンフィグファイル名]」}として取得したもの]をログ出力する
				「[アプリのコンフィグフォルダー]Profile\ProfileConfig\[プロファイルのID].cfg」を「[アプリのコンフィグフォルダー]Profile\ProfileConfig\[プロファイルコンフィグファイル名]」へコピーする
				
			// そうでない場合は既存のファイルをコピーする
			そうでなければ
				「- [プロファイルコンフィグフォルダー]profile.cfg → [アプリのコンフィグフォルダー]Profile\ProfileConfig\[プロファイルコンフィグファイル名]」をログ出力する
				「[プロファイルコンフィグフォルダー]profile.cfg」を「[アプリのコンフィグフォルダー]Profile\ProfileConfig\[プロファイルコンフィグファイル名]」へコピーする
				
			もし終わり
			「完了」をログ出力する
		発生した場合
			エラーのメッセージというエラーを発生させる
		監視終わり
	終わり
	
	プロファイルコンフィグ復元する手順
		ステータス番号=21
		
		例外監視
			もし(プロファイルのプロファイルコンフィグ指定が2)かつ(「[アプリのコンフィグフォルダー]Profile\ProfileConfig\[プロファイルコンフィグファイル名]」が存在する)なら
				「プロファイルコンフィグファイルを復元」をログ出力する
				
				【保存ファイルパス】=「[プロファイルコンフィグフォルダー]profile.cfg」 // ゲームが読み込むファイルのパス
				【共通ファイルパス】=「[アプリのコンフィグフォルダー]Backup\ProfileConfig\profile.cfg」 // 共通ファイルのバックアップのパス
				【固有ファイルパス】=「[アプリのコンフィグフォルダー]Profile\ProfileConfig\[プロファイルコンフィグファイル名]」 // 固有ファイルのパス
				【元ファイル属性】
				
				// 元のファイル属性を取得する
				元ファイル属性=固有ファイルパスからファイル属性を取得したもの
				// ファイル属性を一時的にリセット
				固有ファイルパスへ「標準」というファイル属性を設定する
				
				// プロファイル固有のコンフィグファイルを保存する
				「- プロファイル固有のプロファイルコンフィグを保存」をログ出力する
				保存ファイルパスを固有ファイルパスへコピーする
				
				// ファイル属性を復元する
				固有ファイルパスへ元ファイル属性というファイル属性を設定する
				
				
				// 元のファイル属性を取得する
				元ファイル属性=保存ファイルパスからファイル属性を取得したもの
				// ファイル属性を一時的にリセット
				保存ファイルパスへ「標準」というファイル属性を設定する
				
				// バックアップしたコンフィグファイルをコンフィグフォルダーへコピーする
				「- 標準のプロファイルコンフィグを復元」をログ出力する
				共通ファイルパスを保存ファイルパスへコピーする
				
				// ファイル属性を復元する
				保存ファイルパスへ元ファイル属性というファイル属性を設定する
				
				「完了」をログ出力する
			もし終わり
		発生した場合
			エラーのメッセージというエラーを発生させる
		監視終わり
	終わり
	
	-初期ビデオコンフィグ:辞書
	-ビデオコンフィグファイル:ファイル情報
	-ビデオコンフィグファイル名:文字列
	ビデオコンフィグ取得する手順
		ステータス番号=16
		
		例外監視
			「ビデオコンフィグファイルを取得」をログ出力する
			
			// プロファイル固有のビデオコンフィグを読み込むための処理
			もし(プロファイルのビデオコンフィグ指定が2)なら
				// プロファイル固有のビデオコンフィグファイルが見つからない場合は作成(通常のビデオコンフィグファイルをコピー)する
				もし「[アプリのコンフィグフォルダー]Profile\VideoConfig\[ビデオコンフィグファイル名]」が存在しないなら
					ビデオコンフィグ作成する
				もし終わり
				
				// 通常のビデオコンフィグファイルの内容を取得する
				【ビデオコンフィグファイルデータ】=「[コンフィグフォルダー]videoconfig.txt」から読み込んだもの
				初期ビデオコンフィグ=[ビデオコンフィグファイルデータをVDF形式として読み取ったもの]をJSON形式として読み取ったもの
				
				// 通常のビデオコンフィグファイルを避難させる (バックアップ)
				「[コンフィグフォルダー]videoconfig.txt」を「[アプリのコンフィグフォルダー]Backup\VideoConfig\videoconfig.txt」へコピーする
				
				// ファイル属性をリセット
				「[アプリのコンフィグフォルダー]Backup\VideoConfig\videoconfig.txt」へ「標準」というファイル属性を設定する
				「[コンフィグフォルダー]videoconfig.txt」へ「標準」というファイル属性を設定する
				
				// プロファイル固有のビデオコンフィグファイルをビデオコンフィグフォルダーへコピーする
				「[アプリのコンフィグフォルダー]Profile\VideoConfig\[ビデオコンフィグファイル名]」を「[コンフィグフォルダー]videoconfig.txt」へコピーする
			もし終わり
			
			// 読み取り専用が有効ならファイル属性へ読み取り専用を設定する
			もし(プロファイルのビデオコンフィグ読み取り専用が○)なら
				「[コンフィグフォルダー]videoconfig.txt」へ「読み取り専用」というファイル属性を設定する
				
			そうでなければ
				「[コンフィグフォルダー]videoconfig.txt」へ「標準」というファイル属性を設定する
				
			もし終わり
			
			ビデオコンフィグファイル=ファイル情報(「[コンフィグフォルダー]videoconfig.txt」)を作ったもの
			
			「完了」をログ出力する
		発生した場合
			エラーのメッセージというエラーを発生させる
		監視終わり
	終わり
	
	ビデオコンフィグ作成する手順
		ステータス番号=17
		
		例外監視
			// アカウント切り替え機能実装前のファイルが存在する場合はそのファイルから移行する
			もし「[アプリのコンフィグフォルダー]Profile\VideoConfig\[プロファイルのID].txt」が存在するなら
				「- (移行) [アプリのコンフィグフォルダー]Profile\VideoConfig\[プロファイルのID].txt → [アプリのコンフィグフォルダー]Profile\VideoConfig\[ビデオコンフィグファイル名]」をログ出力する
				「[アプリのコンフィグフォルダー]Profile\VideoConfig\[プロファイルのID].txt」を「[アプリのコンフィグフォルダー]Profile\VideoConfig\[ビデオコンフィグファイル名]」へコピーする
				
			// そうでない場合は既存のファイルをコピーする
			そうでなければ
				「- [コンフィグフォルダー]videoconfig.txt → [アプリのコンフィグフォルダー]Profile\VideoConfig\[ビデオコンフィグファイル名]」をログ出力する
				「[コンフィグフォルダー]videoconfig.txt」を「[アプリのコンフィグフォルダー]Profile\VideoConfig\[ビデオコンフィグファイル名]」へコピーする
				
			もし終わり
			「完了」をログ出力する
		発生した場合
			エラーのメッセージというエラーを発生させる
		監視終わり
	終わり
	
	ビデオコンフィグ復元する手順
		ステータス番号=18
		
		例外監視
			もし(プロファイルのビデオコンフィグ指定が2)かつ(「[アプリのコンフィグフォルダー]Profile\VideoConfig\[ビデオコンフィグファイル名]」が存在する)なら
				「ビデオコンフィグファイルを復元」をログ出力する
				
				【保存ファイルパス】=「[コンフィグフォルダー]videoconfig.txt」 // ゲームが読み込むファイルのパス
				【共通ファイルパス】=「[アプリのコンフィグフォルダー]Backup\VideoConfig\videoconfig.txt」 // 共通ファイルのバックアップのパス
				【固有ファイルパス】=「[アプリのコンフィグフォルダー]Profile\VideoConfig\[ビデオコンフィグファイル名]」 // 固有ファイルのパス
				【元ファイル属性】
				
				// 元のファイル属性を取得する
				元ファイル属性=固有ファイルパスからファイル属性を取得したもの
				// ファイル属性を一時的にリセット
				固有ファイルパスへ「標準」というファイル属性を設定する
				
				// プロファイル固有のコンフィグファイルを保存する
				「- プロファイル固有のビデオコンフィグを保存」をログ出力する
				保存ファイルパスを固有ファイルパスへコピーする
				
				// ファイル属性を復元する
				固有ファイルパスへ元ファイル属性というファイル属性を設定する
				
				
				// 元のファイル属性を取得する
				元ファイル属性=保存ファイルパスからファイル属性を取得したもの
				// ファイル属性を一時的にリセット
				保存ファイルパスへ「標準」というファイル属性を設定する
				
				// バックアップしたコンフィグファイルをコンフィグフォルダーへコピーする
				「- 標準のビデオコンフィグを復元」をログ出力する
				共通ファイルパスを保存ファイルパスへコピーする
				
				// ファイル属性を復元する
				保存ファイルパスへ元ファイル属性というファイル属性を設定する
				
				「完了」をログ出力する
			もし終わり
		発生した場合
			エラーのメッセージというエラーを発生させる
		監視終わり
	終わり*/
	
	【ビデオコンフィグ読み取り専用:真偽値】
	ビデオコンフィグ編集する手順
		ステータス番号=10
		もし(プロファイルのゲーム解像度変更が○)なら
			// ビデオコンフィグを編集する (解像度)
			【設定】={プロファイルのディスプレイ解像度の幅,プロファイルのディスプレイ解像度の高さ}
			もし「[コンフィグフォルダー]videoconfig.txt」というファイルが存在するなら
				ビデオコンフィグ変更=○
				[言語管理器で「InPlay.Log.StartEditingVideoConfig」を取得したもの]をログ出力する
				
				// ビデオコンフィグのバックアップを作成
				//「[コンフィグフォルダー]videoconfig.txt」を「[アプリのコンフィグフォルダー]Backup\VideoConfig\videoconfig_[今を「yyyyMMdd-HHmmss」に整えたもの].txt」へコピーする
				
				// ビデオコンフィグを読み込む
				【コンフィグファイル】=「[コンフィグフォルダー]videoconfig.txt」から読み込んだもの
				「ビデオコンフィグ: [コンフィグファイルをVDF形式として読み取ったもの]」をデバッグログへ出力する
				【コンフィグ】=[コンフィグファイルをVDF形式として読み取ったもの]をJSON形式として読み取ったもの
				
				初期ビデオコンフィグ=[コンフィグファイルをVDF形式として読み取ったもの]をJSON形式として読み取ったもの
				
				コンフィグ(「VideoConfig」)(「setting.defaultres」)=「[設定(1)]」
				コンフィグ(「VideoConfig」)(「setting.defaultresheight」)=「[設定(2)]」
				もしプロファイルの起動引数が「-anticheat_settings=SettingsDX12.json」を含むなら
					コンフィグ(「VideoConfig」)(「setting.fullscreen」)=「1」
					コンフィグ(「VideoConfig」)(「setting.nowindowborder」)=「0」
					
				そうでなければ
					コンフィグ(「VideoConfig」)(「setting.fullscreen」)=「1」
					コンフィグ(「VideoConfig」)(「setting.nowindowborder」)=「0」
					
				もし終わり
				
				// ビデオコンフィグファイルが読み取り専用になっているかチェックする
				もし「[「[コンフィグフォルダー]videoconfig.txt」からファイル属性を取得したもの]」から「読み取り専用」を探したものが1以上なら
					ビデオコンフィグ読み取り専用=○
					
				そうでなければ
					ビデオコンフィグ読み取り専用=×
					
				もし終わり
				
				// ビデオコンフィグファイルを削除する
				「[コンフィグフォルダー]videoconfig.txt」へ「標準」というファイル属性を設定する
				「[コンフィグフォルダー]videoconfig.txt」を削除する
				// 編集したビデオコンフィグをファイルに保存する
				コンフィグをJSON形式として書き出したものをVDF形式として書き出したものを「[コンフィグフォルダー]videoconfig.txt」へ保存する
				[言語管理器で「InPlay.Log.Done」を取得したもの]をログ出力する
				○を返す
				
			そうでなければ
				ビデオコンフィグ変更=×
				×を返す
				
			もし終わり
		もし終わり
	終わり
	
	// ビデオコンフィグの変更した項目(主に解像度の設定)を復元する
	ビデオコンフィグ削除する手順
		もし(「[コンフィグフォルダー]videoconfig.txt」というファイルが存在する)かつ(ビデオコンフィグ変更が○)なら
			「初期ビデオコンフィグ: [初期ビデオコンフィグをJSON形式として書き出したもの]」をデバッグログへ出力する
			
			【コンフィグファイル】=「[コンフィグフォルダー]videoconfig.txt」から読み込んだもの
			【コンフィグ】=[コンフィグファイルをVDF形式として読み取ったもの]をJSON形式として読み取ったもの
			「コンフィグ種類: [コンフィグの種類名]」をデバッグログへ出力する
			
			「現在ビデオコンフィグ: [コンフィグファイルをVDF形式として読み取ったもの]」をデバッグログへ出力する
			
			// ビデオコンフィグを元に戻す
			もし(コンフィグに「VideoConfig」が存在する)かつ(初期ビデオコンフィグが無でない)なら
				もしコンフィグ(「VideoConfig」)に「setting.defaultres」が存在するなら、コンフィグ(「VideoConfig」)へ「setting.defaultres」として「[初期ビデオコンフィグ(「VideoConfig」)(「setting.defaultres」)]」を設定する
				もしコンフィグ(「VideoConfig」)に「setting.defaultresheight」が存在するなら、コンフィグ(「VideoConfig」)へ「setting.defaultresheight」として「[初期ビデオコンフィグ(「VideoConfig」)(「setting.defaultresheight」)]」を設定する
				もしコンフィグ(「VideoConfig」)に「setting.fullscreen」が存在するなら、コンフィグ(「VideoConfig」)へ「setting.fullscreen」として「[初期ビデオコンフィグ(「VideoConfig」)(「setting.fullscreen」)]」を設定する
				もしコンフィグ(「VideoConfig」)に「setting.nowindowborder」が存在するなら、コンフィグ(「VideoConfig」)へ「setting.nowindowborder」として「[初期ビデオコンフィグ(「VideoConfig」)(「setting.nowindowborder」)]」を設定する
				「更新後ビデオコンフィグ: [コンフィグをJSON形式として書き出したもの]」をデバッグログへ出力する
				
				// 現在のコンフィグファイルを削除する
				「[コンフィグフォルダー]videoconfig.txt」へ「標準」というファイル属性を設定する
				「[コンフィグフォルダー]videoconfig.txt」を削除する
				
				// 更新したコンフィグをファイルへ保存
				コンフィグをJSON形式として書き出したものをVDF形式として書き出したものを「[コンフィグフォルダー]videoconfig.txt」へ保存する
				
				// 元のビデオコンフィグファイルが読み取り専用の場合、保存したファイルを読み取り専用にする
				もしビデオコンフィグ読み取り専用が○なら「[コンフィグフォルダー]videoconfig.txt」へ「読み取り専用」というファイル属性を設定する
			もし終わり
		もし終わり
	終わり
	
	-元ディスプレイ設定:ディスプレイ設定
	システムディスプレイ解像度変更する手順
		ステータス番号=2
		// システムのディスプレイ解像度を変更する
		もし(プロファイルのゲーム解像度変更が○)かつ(プロファイルのディスプレイ解像度変更が○)なら
			[言語管理器で「InPlay.Log.SystemDisplaySettings_Get」を取得したもの]をログ出力する
			元ディスプレイ設定=ディスプレイ管理器でメインディスプレイから設定を取得したもの
			[言語管理器で「InPlay.Log.SystemDisplaySettings_Change」を取得したもの]をログ出力する
			「- [プロファイルのディスプレイ解像度の幅]×[プロファイルのディスプレイ解像度の高さ]@[プロファイルのディスプレイリフレッシュレート]Hz ([プロファイルのディスプレイスケーリングモード])」をログ出力する
			メイン画面の起動中パネルのプレイ処理状況=言語管理器で「InPlay.Status.ChangingDisplaySettings」を取得したもの
			【サイズ変更結果】=ディスプレイ管理器でメインディスプレイへ{プロファイルのディスプレイ解像度の幅, プロファイルのディスプレイ解像度の高さ, プロファイルのディスプレイリフレッシュレート, プロファイルのディスプレイスケーリングモード}を「レジストリー更新」として設定する
			もしサイズ変更結果が「不正な設定」なら
				[言語管理器で「InPlay.Error.SystemDisplaySettings_UnsupportedDisplaySettings」を取得したもの]というエラーを発生させる
				
			他でもしサイズ変更結果が「成功」でないなら
				「[言語管理器で「InPlay.Log.Error」を取得したもの]: [サイズ変更結果]」というエラーを発生させる
				
			もし終わり
			[言語管理器で「InPlay.Log.Done」を取得したもの]をログ出力する
		もし終わり
	終わり
	
	プロセス起動する手順
		ステータス番号=3
		// Apex Legends を起動する
		ApexLegendsインストールパス=プロファイルのApexLegendsバイナリーパス
		[言語管理器で「InPlay.Log.Game_Starting」を取得したもの]をログ出力する
		メイン画面の起動中パネルのプレイ処理状況=言語管理器で「InPlay.Status.StartingGame」を取得したもの
		もしApexLegendsインストールパスというファイルが存在しないなら
			監視終了する
			{×,[言語管理器で「InPlay.Error.FailedToLaunch_FileNotFound」を{[インストールパス]}として取得したもの],3}を返す
		もし終わり
		
		// 起動引数を取得する
		【起動引数:文字列】=「[プロファイルの起動引数]」
		
		「- [言語管理器で「InPlay.Log.Platform」を取得したもの]: [プロファイルのApexLegendsプラットフォーム]」をログ出力する
		
		////////// EA app //////////
		もしプロファイルのApexLegendsプラットフォームが「EA app」なら
			// Steam 経由で EA app を起動するオプションが有効の場合は、すでに起動している EA app を終了して Steam 経由で起動する
			もしプロファイルのEAappSteam経由起動が◯なら
				【EAappプロセス】
				【EAappプロセス一覧:配列】
				
				[言語管理器で「InPlay.Log.EAapp_GetProcess」を取得したもの]をログ出力する
				EAappプロセス=EAappのアプリプロセス
				もしEAappプロセスが無でないなら // EA app のプロセスが見つかった場合はプロセスを終了させる
					EAappを終了する
					「- PID: [EAappプロセスのID]」をログ出力する
					[言語管理器で「InPlay.Log.EAapp_TerminateProcess」を取得したもの]をログ出力する

				そうでなければ // EA app のプロセスが見つからなかった場合はなにもしない
					[言語管理器で「InPlay.Log.EAapp_ProcessNotFound」を取得したもの]をログ出力する

				もし終わり
				// Steam を経由して起動する
				[言語管理器で「InPlay.Log.EAapp_Launch_ViaSteam」を取得したもの]をログ出力する
				「- steam://rungameid/[プロファイルのEAappSteam経由起動AppID]」をログ出力する
				Steamで[プロファイルのEAappSteam経由起動AppID]を非Steam起動する
				// プロセスを取得
				「 - 」&[言語管理器で「InPlay.Log.EAapp_SearchingForProcess」を取得したもの]をログ出力する
				EAappプロセス=無
				30回繰り返す
					EAappプロセス=EAappのアプリプロセス
					もしEAappプロセスが無でないなら繰り返しから抜け出す
					1秒待つ
				繰り返し終わり
				もしEAappプロセスが無なら
					[言語管理器で「InPlay.Error.EAapp_FindProcess_Timeout」を取得したもの]というエラーを発生させる
				もし終わり
				「- PID: [EAappプロセスのID]」をログ出力する
				
				// EA app のウィンドウが表示されるのを待つ
				「 - 」&[言語管理器で「InPlay.Log.EAapp_WaitingForWindow」を取得したもの]をログ出力する
				30回繰り返す
					もしEAappプロセスのメインウィンドウハンドルが0でないなら繰り返しから抜け出す
					1秒待つ
				繰り返し終わり
				もしEAappプロセスのメインウィンドウハンドルが0なら[言語管理器で「InPlay.Error.EAapp_CouldNotGetWindowHandle」を取得したもの]というエラーを発生させる
				「  - [言語管理器で「InPlay.Log.MainWindowHandle」を取得したもの]: [EAappプロセスのメインウィンドウハンドル]」をログ出力する
				// メインウィンドウが表示されるまで待機する
				10秒待つ
			もし終わり
			
			// Apex Legends を起動する
			「- [言語管理器で「InPlay.Log.Path」を取得したもの]: [EAappのインストール先]EA Desktop\EALaunchHelper.exe "origin2://game/launch/?offerIds=194908&cmdParams=[起動引数]"」をログ出力する
			EAappで「194908」を起動引数としてゲーム起動する
		もし終わり
		////////// EA app //////////
		
		////////// Steam //////////
		もしプロファイルのApexLegendsプラットフォームが「Steam」なら
			[言語管理器で「InPlay.Log.Game_Launch」を取得したもの]をログ出力する
			「- [言語管理器で「InPlay.Log.Path」を取得したもの]: [Steamのインストール先]steam.exe -applaunch 1172470 [起動引数]」をログ出力する
			Steamで「1172470」を起動引数として起動する
		もし終わり
		////////// Steam //////////
		
		//「"[EAappのインストール先]EA Desktop\compatibility32\EADesktop.exe"」を「[EAappプロセスのID]」として起動する
	終わり
	
	+待機キャンセル:真偽値
	プロセス起動待機する手順
		ステータス番号=3
		
		メイン画面の起動中パネルのキャンセルボタンを表示する
		
		// Apex Legends が起動するまで待つ
		【待機時間】=120 // 秒
		【待機時間カウント】=待機時間
		【インストール待機時間】=3600 // 秒
		【インストール待機時間カウント】=インストール待機時間
		【インストール開始:真偽値】=×
		【インストール終了:真偽値】=×
		【Apexプロセス】=無
		【EABSプロセス】=無
		【EABS再起動質問結果】
		【ゲームステータス:辞書】
		【キャンセル理由:文字列】=「」
		
		繰り返す
			Apexプロセスが無でないなら繰り返しから抜ける // プロセスが見つかった場合に繰り返しから抜ける
			待機キャンセルが○なら繰り返しから抜ける // 待機がキャンセルされた場合に繰り返しから抜ける
			待機時間カウントが0なら繰り返しから抜ける // ゲームの起動が時間内に終わらなかった場合に繰り返しから抜ける
			インストール待機時間カウントが0なら繰り返しから抜ける // インストールが時間内に終わらなかった場合に繰り返しから抜ける
			
			例外監視
				インストール終了でないなら
					// ゲームのステータスを取得してチェック
					ゲームステータス=EAappでゲームステータス取得する
					
					[ゲームステータス(「offerId」)が「Origin.OFR.50.0002694」]なら // ゲームが Apex Legends か判定
						// インストールor修復実行中の場合 処理が終了するまで待機する
						[ゲームステータス(「gameStatus」)(「installing」)]かつ[ゲームステータス(「gameStatus」)(「updating」)]でないなら
							// 修復
							[ゲームステータス(「installInfo」)(「installReason」)]が「REPAIR」なら
								インストール開始でないなら
									[言語管理器で「InPlay.Status.WaitingForGameRepairProcess」を取得したもの]をログ出力する
									インストール開始=○
								そして
								メイン画面の起動中パネルのプレイ処理状況=[言語管理器で「InPlay.Status.WaitingForGameRepairProcess_WithStatus」を{[ゲームステータス(「installInfo」)(「installStatusString」)],[ゲームステータス(「installInfo」)(「installPhaseString」)]}として取得したもの]
								
							// インストール
							そうでなければ
								インストール開始でないなら
									[言語管理器で「InPlay.Status.WaitingForGameInstallProcess」を取得したもの]をログ出力する
									インストール開始=○
								そして
								メイン画面の起動中パネルのプレイ処理状況=[言語管理器で「InPlay.Status.WaitingForGameInstallProcess_WithStatus」を{[ゲームステータス(「installInfo」)(「installStatusString」)],[ゲームステータス(「installInfo」)(「installPhaseString」)]}として取得したもの]
								
							そして
							
							インストール待機時間カウント=インストール待機時間カウント-1
							1秒待つ
							繰り返しを続ける
							
						// アップデート実行中の場合 処理が終了するまで待機する
						他で[ゲームステータス(「gameStatus」)(「installing」)]かつ[ゲームステータス(「gameStatus」)(「updating」)]なら
							インストール開始でないなら
								[言語管理器で「InPlay.Status.WaitingForGameUpdateProcess」を取得したもの]をログ出力する
								インストール開始=○
							そして
							メイン画面の起動中パネルのプレイ処理状況=[言語管理器で「InPlay.Status.WaitingForGameUpdateProcess_WithStatus」を{[ゲームステータス(「installInfo」)(「installStatusString」)],[ゲームステータス(「installInfo」)(「installPhaseString」)]}として取得したもの]
							インストール待機時間カウント=インストール待機時間カウント-1
							1秒待つ
							繰り返しを続ける
							
						そして
						
						// インストール完了/キャンセル
						インストール開始かつ[ゲームステータス(「gameStatus」)(「installing」)]でないかつ[ゲームステータス(「gameStatus」)(「updating」)]でないなら
						// インストール処理がキャンセルされた場合 待機をキャンセルする
							[ゲームステータス(「installInfo」)(「installStatus」)]が4なら
								キャンセル理由=[言語管理器で「InPlay.Status.CancelingGameInstall」を取得したもの]
								待機キャンセル=○
								繰り返しから抜ける
								
							// インストール処理が完了した場合 ゲームを起動する
							他で[ゲームステータス(「installInfo」)(「installStatus」)]が5かつインストール開始なら
								インストール終了でないなら
									インストール終了=○
									// ゲームを起動する (EALaunchHelperを呼ぶとEA appも起動するので、EABackgroundServiceも勝手に開始される)
									プロセス起動する
								そして
								
							そして
							
						そして
					そして
				そして
			発生した場合
				「ゲームステータス取得エラー: [エラーのメッセージ]」を「エラー」としてデバッグログへ出力する
			監視終わり
			
			例外監視
				// 1分経過しても起動しない場合はEABackgroundServiceの再起動を勧めるダイアログを表示する (EA appのみ)
				待機時間カウントが60かつプロファイルのApexLegendsプラットフォームが「EA app」なら
					EABS再起動質問結果=[言語管理器で「InPlay.Dialog.Game_WontStart」を取得したもの]を「情報アイコン」にして「はいといいえ」で質問したもの
					EABS再起動質問結果が「はい」なら
						// 待機時間をリセットする
						待機時間カウント=待機時間
						// EA app と EABackgroundServiceを停止する
						EAappを終了する
						EAappでバックグラウンドサービス終了する
						1秒待つ
						// ゲームを起動する (EALaunchHelperを呼ぶとEA appも起動するので、EABackgroundServiceも勝手に開始される)
						プロセス起動する
					そして
				そして
				
				// カウントの表示を更新
				メイン画面の起動中パネルのプレイ処理状況=言語管理器で「InPlay.Status.WaitingForGameToStart_WithRT」を{[待機時間カウント]}として取得したもの
				
			発生した場合
				「プロセス待機ループエラー: [エラーのメッセージ]」を「エラー」としてデバッグログへ出力する
			監視終わり
			
			例外監視
				Apexプロセス=実行ファイル名のプロセス
			発生した場合
				//「プロセス取得エラー: [エラーのメッセージ]」を「エラー」としてデバッグログへ出力する
				Apexプロセス=無
			監視終わり
			
			待機時間カウント=待機時間カウント-1
			
			1秒待つ
		そして
		
		// 待機キャンセル
		待機キャンセルが○なら
			ステータス番号=11
			メイン画面の起動中パネルのキャンセルボタンを隠す
			キャンセル理由というエラーを発生させる
		そして
		
		// 待機タイムアウト
		Apexプロセスが無なら
			[言語管理器で「InPlay.Error.Game_CouldNotGetProcess_Timeout」を取得したもの]というエラーを発生させる
		そして
		
		メイン画面の起動中パネルのキャンセルボタンを隠す
	終わり
	
	-最新タイトル画面取得結果:配列
	-最新タイトル画像ファイル名:文字列
	最新タイトル画面取得する手順:配列
		例外監視
			// 最新の画像ファイル名を取得する
			【要求内容:HTTP要求】=HTTP要求を作ったもの
			要求内容の文字コード=「UTF-8」
			【応答内容:HTTP応答】=「https://raw.githubusercontent.com/femtoCommunity/LegendUtil/Resources/Images/TitleScreen/Latest.txt」を要求内容にてHTTPで要求したもの
			最新タイトル画像ファイル名=応答内容の本文
			最新タイトル画像ファイル名=最新タイトル画像ファイル名で[改行]を「」へ置換したもの
			
			「 - URL: https://raw.githubusercontent.com/femtoCommunity/LegendUtil/Resources/Images/TitleScreen/[最新タイトル画像ファイル名]」をログ出力する
			「 - [言語管理器で「InPlay.Log.Path」を取得したもの]: [アプリのコンフィグフォルダー]Resources\TitleScreenImage\[最新タイトル画像ファイル名]」をログ出力する
			
			// 最新の画像ファイル名を取得できなかった場合
			もし(HTTPのステータスコードが200でない)または(最新タイトル画像ファイル名が無)なら
				{×,[言語管理器で「InPlay.Log.TitleScreenImage_CouldNotGetLatestImageFileName」を{[HTTPのステータスコード]}として取得したもの]}を返す
			もし終わり
			
			// 既に最新の画像ファイルがダウンロードされている場合
			もし「[アプリのコンフィグフォルダー]Resources\TitleScreenImage\[最新タイトル画像ファイル名]」が存在するなら
				{○,[言語管理器で「InPlay.Log.TitleScreenImage_AlreadyDownloaded」を{[HTTPのステータスコード]}として取得したもの]}を返す
				
			// 最新の画像ファイルがダウンロードされていない場合
			そうでなければ
				// 画像ファイルをダウンロード
				「https://raw.githubusercontent.com/femtoCommunity/LegendUtil/Resources/Images/TitleScreen/[最新タイトル画像ファイル名]」を「[アプリのコンフィグフォルダー]Resources\TitleScreenImage\[最新タイトル画像ファイル名]」へHTTPでダウンロードする
				もしHTTPのステータスコードが200でないなら{×,[言語管理器で「InPlay.Log.TitleScreenImage_FailedToDownload」を{[最新タイトル画像ファイル名],[HTTPのステータスコード]}として取得したもの]}を返す
				そうでなければ{○,「[言語管理器で「InPlay.Log.Download」を取得したもの] - [最新タイトル画像ファイル名の名前だけ] | [言語管理器で「InPlay.Log.StatusCode」を取得したもの]: [HTTPのステータスコード]」}を返す
				
			もし終わり
		発生した場合
			{×,[エラーのメッセージ]}を返す
		監視終わり
	終わり
	
	【AltEnter自動押下処理スレッド:スレッド】
	AltEnter自動押下実行する手順
		AltEnter自動押下処理スレッドというスレッドを作る
		AltEnter自動押下処理スレッドのバックグラウンド=○
		// Alt+Enter の自動押下処理
		AltEnter自動押下処理スレッドで『
		もし(プロファイルのゲーム解像度変更が○)かつ(プロファイルのAltEnter自動押下が○)かつ(最新タイトル画面取得結果(1)が○)なら
			ステータス番号=6
			
			1秒待つ
			
			[言語管理器で「InPlay.Log.AltEnterAutoPress_Waiting」を取得したもの]をログ出力する
			// 画像認識が有効の場合は画面をキャプチャーして、類似度が一定の数値以下になったら自動押下を実行する
			もしプロファイルのAltEnter自動押下画像比較が○なら
				もし「[アプリのコンフィグフォルダー]Resources\TitleScreenImage\[最新タイトル画像ファイル名]」というファイルが存在しないなら「- 」&[言語管理器で「InPlay.Log.AltEnterAutoPress_CannotExecute_TitleScreenImageNotFound」を取得したもの]をログ出力する
				【タイトル画面:画像】=画像(「[アプリのコンフィグフォルダー]Resources\TitleScreenImage\[最新タイトル画像ファイル名]」)を作ったもの
				【キャプチャー画像:画像】
				【類似度:浮動小数】
				「- 」&[言語管理器で「InPlay.Log.AltEnterAutoPress_WaitingForTitleScreen」を取得したもの]をログ出力する
				60回繰り返す
					もし監視有効が×なら繰り返しから抜け出す
					もしプロセスのメインウィンドウハンドルが0でないなら
						// Apex Legends のウィンドウに切り替える
						メイン画面にフォーカスする
						プロセスへ切り替える
						もし選択プロセスのIDがプロセスのIDなら
							// 画面をキャプチャーする
							//キャプチャー画像=プロセスのメインウィンドウハンドルをウィンドウキャプチャーでキャプチャーしたもの
							キャプチャー画像=スクリーンショットとして現在ウィンドウを取り込んだもの
							
							// 類似度を判定
							類似度={タイトル画面, キャプチャー画像}から画像処理で類似度取得する
							もし類似度が「NaN」なら類似度=1000
							//「 - [言語管理器で「InPlay.Log.ImageSimilarity」を取得したもの]: [類似度]」をログ出力する
							
							// 類似度が90以下の場合Alt+Enter押下を実行する
							もし類似度が90以下なら
								「 - [言語管理器で「InPlay.Log.ImageSimilarity」を取得したもの]: [類似度]」をログ出力する
								AltEnter押下実行する
								繰り返しから抜け出す
							もし終わり
							
						そうでなければ
							「 - 」&[言語管理器で「InPlay.Log.AltEnterAutoPress_ScreenCaptureFailed_ProcessWindowNotSelected」を取得したもの]をログ出力する
							
						もし終わり
						1秒待つ
						
					そうでなければ
						「 - 」&[言語管理器で「InPlay.Log.AltEnterAutoPress_WaitingForWindow」を取得したもの]をログ出力する
						1秒待つ
						
					もし終わり
				繰り返し終わり
				キャプチャー画像をウィンドウ部品制御で解放する
				
			// 画像認識が無効の場合は指定された時間待機して自動押下を実行する
			そうでなければ
				// Alt+Enter 押下までの待機
				【AltEnter待機時間】=プロファイルAltEnter自動押下待機時間
				もしAltEnter待機時間が1以上でないならAltEnter待機時間=30
				
				「- 」&[言語管理器で「InPlay.Log.AltEnterAutoPress_WaitingTime」を{[AltEnter待機時間]}として取得したもの]をログ出力する
				
				【残り時間】=AltEnter待機時間
				[AltEnter待機時間]回繰り返す
					もし監視有効が×なら繰り返しから抜け出す
					残り時間=残り時間-1
					「 - 」&[言語管理器で「InPlay.Log.AltEnterAutoPress_WaitingTime_Left」を{[残り時間]}として取得したもの]をログ出力する
					1秒待つ
				繰り返し終わり
				もし残り時間が0ならAltEnter押下実行する
				
			もし終わり
		もし終わり
		』を実行する
	終わり
	
	AltEnter押下実行する手順
		ステータス番号=7
		// Alt+Enter の自動押下処理
		[言語管理器で「InPlay.Log.AltEnterAutoPress_Execute」を取得したもの]をログ出力する
		もしプロセスの起動中が○なら
			プロセスへ「%{Enter}」を入力する
			2秒待つ
			プロセスへ「%{Enter}」を入力する
		もし終わり
	終わり
	
	-カーソルロック実行中:真偽値
	-カーソルロックスレッド:スレッド
	カーソルロック開始する手順
		// Apex Legends のウィンドウが存在する場合、カーソルのロックを有効化する
		例外監視
			もしカーソルロック実行中なら手順から抜け出す
			もしプロファイルのカーソルロックが○なら // カーソルロックが有効の場合 有効化処理を実行する
				もし(カーソルロッカーのロック中が○でない)かつ(プロセスのメインウィンドウハンドルが0でない)なら
					カーソルロックスレッドというスレッドを作る
					カーソルロックスレッドで『
						カーソルロック実行中=○
						[言語管理器で「InPlay.Log.CursorLock_Enabled」を取得したもの]をログ出力する
						「- [言語管理器で「InPlay.Log.WindowHandle」を取得したもの]: [プロセスのメインウィンドウハンドル]」をログ出力する
						メイン画面の起動中パネルのカーソル状態ラベルの内容=[言語管理器で「General.General.4」を取得したもの]
						プロセスのメインウィンドウハンドルへカーソルロッカーでロックする
						カーソルロッカーでロック解除する
						[言語管理器で「InPlay.Log.CursorLock_Disabled」を取得したもの]をログ出力する
						カーソルロック実行中=×
					』を実行する
				もし終わり
				
			そうでなければ // カーソルロックが無効の場合
				メイン画面の起動中パネルのカーソル状態ラベルの内容=[言語管理器で「General.General.6」を取得したもの]
				カーソルロック実行中=×
				
			もし終わり
		発生した場合
			エラーのメッセージを「エラー」としてデバッグログへ出力する
			カーソルロック実行中=×
		監視終わり
	終わり
	////////// 起動処理の手順 //////////
	
	起動中パネル表示する手順
		メイン画面を表示する
		メイン画面のメインメニューパネルのプロファイル一覧選択リストパネルの有効=×
		メイン画面のメインメニューパネルのプレイボタンの有効=×
		メイン画面のツールバータブパネルの有効=×
		メイン画面のアップデートチェックボタンの有効=×
		メイン画面のメインメニューパネルの起動中ベースパネルを最前面
		メイン画面のメインメニューパネルの起動中ベースパネルを表示する
		
		// システム情報: 一時的に無効化
		メイン画面のメインメニューパネルの起動中パネルのシステム情報パネルの表示=×
	終わり
	
	起動中パネル隠す手順
		メイン画面の起動中パネルの終了処理=○
		メイン画面のメインメニューパネルの起動中ベースパネルを隠す
		メイン画面のアップデートチェックボタンの有効=○
		メイン画面のツールバータブパネルの有効=○
		メイン画面のメインメニューパネルのプレイボタンの内容=言語管理器で「1.3.1」を取得したもの
		メイン画面のメインメニューパネルのプレイボタン状態=1
		メイン画面のメインメニューパネルのプレイボタンの有効=○
		メイン画面のメインメニューパネルのプロファイル一覧選択リストパネルの有効=○
		休憩する
		メイン画面をメイン画面のメインメニューパネルへ切り替える
	終わり
	
	-監視有効:真偽値
	+監視強制終了:真偽値
	+監視スレッド:スレッド
	+プロセス:プロセス
	+プロセス起動中:真偽値
	-プレイ開始日時:日時形式
	-プレイ終了日時:日時形式
	自分を監視開始する手順
		もし監視有効が○なら手順から抜け出す
		
		//例外監視
		監視強制終了=×
		監視有効=○
		
		監視スレッドというスレッドを作る
		監視スレッドのバックグラウンド=○
		監視スレッドで『
			//例外監視
			// システム情報: 一時的に無効化
			//【CPU使用率:浮動小数】
			//【GPU使用率:浮動小数】
			
			ビルド情報取得する
			
			起動中パネル表示する
			
			メイン画面のメインメニューパネルのプレイボタンの内容=言語管理器で「1.3.3」を取得したもの
			メイン画面のメインメニューパネルのプレイボタン状態=2
			メイン画面のメインメニューパネルのプレイボタンの有効=○
			
			// プロセスを取得する
			例外監視
				【起動中プロセスファイル情報:ファイルバージョン情報】
				【起動中プロセス:プロセス】
				プロセス=無
				実行ファイル名のプロセス一覧を起動中プロセスへそれぞれ繰り返す
					起動中プロセスファイル情報というファイルバージョン情報(インストールパスのフォルダだけ&実行ファイル名&「.exe」)を作る
					もし起動中プロセスファイル情報の説明が「Apex Legends」かつ起動中プロセスファイル情報の会社名が「Respawn Entertainment」かつ起動中プロセスファイル情報の製品名が「Apex Legends」なら
						プロセス=起動中プロセス
						プロセス起動中=プロセスの起動中
					もし終わり
				繰り返し終わり
				もしプロセスが無ならプロセス起動中=×
			発生した場合
				プロセス起動中=×
			監視終わり
			
			もしプロセス起動中が○なら
				[言語管理器で「InPlay.Log.Game_StartProcessTracking」を取得したもの]をログ出力する
				「- PID: [プロセスのID]」をログ出力する
				// プレイ開始日時を記録する
				プレイ開始日時=今
				// Discord RPC を更新する
				例外監視
					RPC管理器で[RPC管理器で「DiscordRPC.Playing.Playing_Details」を取得したもの]を[RPC管理器で「DiscordRPC.Playing.Playing_State」を{[プロファイルの名前]}として取得したもの]としてステータス更新する
					RPC管理器で{プレイ開始日時}としてタイムスタンプ更新する
				発生した場合
					「Discord RPC 更新エラー: [エラーのメッセージ]」を「エラー」としてデバッグログへ出力する
				監視終わり
				// システム情報: 一時的に無効化
				// CPU/GPUカウンターを設定
				//システム情報で[プロセスのID]としてCPUカウンター設定する
				//システム情報で[プロセスのID]としてGPUカウンター一覧取得する
			もし終わり
			
			監視有効の間繰り返す
				// プロセスを強制的に終了させて監視を終了する
				もし監視強制終了かつプロセスが無でないなら
					メイン画面の起動中パネルのプレイ処理状況=言語管理器で「InPlay.Status.StoppingGameProcess」を取得したもの
					プロセスを終了する
					繰り返しから抜け出す
				もし終わり
				
				// Apex Legendsが起動しているかチェック
				例外監視
					プロセス起動中=プロセスの起動中
				発生した場合
					プロセス起動中=×
				監視終わり
				もしプロセスが無ならプロセス起動中=×
				
				もしプロセス起動中なら
					// カーソルロックを有効化する (既に有効になっている場合は何も実行されない)
					カーソルロック開始する
					// システム情報: 一時的に無効化
					//CPU使用率=システム情報からCPU使用率取得したもの
					//GPU使用率=システム情報からGPU使用率取得したもの
					メイン画面の起動中パネルのプレイ処理状況=言語管理器で「InPlay.Status.MonitoringGameProcess」を取得したもの
					// システム情報: 一時的に無効化
					//メイン画面の起動中パネルのCPU使用率ラベルの内容=「[CPU使用率] %」
					//メイン画面の起動中パネルのGPU使用率ラベルの内容=「[GPU使用率] %」
					メイン画面の起動中パネルのPIDラベルの内容=プロセスのID
					
				そうでなければ
					メイン画面の起動中パネルのプレイ処理状況=言語管理器で「InPlay.Status.ProcessingTermination」を取得したもの
					// システム情報:
					//メイン画面の起動中パネルのCPU使用率ラベルの内容=「-----」
					//メイン画面の起動中パネルのGPU使用率ラベルの内容=「-----」
					メイン画面の起動中パネルのPIDラベルの内容=「-----」
					繰り返しから抜け出す
					
				もし終わり
				0.5秒待つ
			繰り返し終わり
			
			監視終了する
			
			起動処理中=×
			//発生した場合
			//	[言語管理器で「InPlay.ErrorLog.ProcessTrackingError」を{[エラーのメッセージ]}として取得したもの]を「エラー」としてログ出力する
			//	監視終了する
			//監視終わり
		』を実行する
		//発生した場合
		//	[言語管理器で「InPlay.ErrorLog.ProcessTrackingError」を{[エラーのメッセージ]}として取得したもの]を「エラー」としてログ出力する
		//	監視終了する
		//監視終わり
	終わり
	
	システムディスプレイ解像度復元する手順
		// ディスプレイの解像度を変更前に戻す
		例外監視
			もしプロファイルが無でないなら
				もし(プロファイルのゲーム解像度変更が○)かつ(プロファイルのディスプレイ解像度変更が○)なら
					[言語管理器で「InPlay.Log.SystemDisplaySettings_Restore」を取得したもの]をログ出力する
					「- [元ディスプレイ設定の幅]×[元ディスプレイ設定の高さ]@[元ディスプレイ設定のリフレッシュレート]Hz」をログ出力する
					【サイズ変更結果】=ディスプレイ管理器でメインディスプレイへ{元ディスプレイ設定の幅, 元ディスプレイ設定の高さ, 元ディスプレイ設定のリフレッシュレート, 元ディスプレイ設定のスケーリングモード}を「レジストリー更新」として設定する
					「 - [サイズ変更結果]」をログ出力する
				もし終わり
			もし終わり
		発生した場合
			[言語管理器で「InPlay.ErrorLog.SystemDisplaySettings_RestoringError」を取得したもの]を「エラー」としてログ出力する
			エラーのメッセージを「エラー」としてログ出力する
		監視終わり
	終わり
	
	-監視終了処理実行中:真偽値
	監視終了処理実行する手順
		もし監視終了処理実行中なら手順から抜け出す
		監視終了処理実行中=○
		
		[言語管理器で「InPlay.Log.Game_EndProcessTracking」を取得したもの]をログ出力する
		メイン画面のメインメニューパネルのプレイボタンの有効=×
		監視有効=×
		
		// 最終プレイ日時の記録
		例外監視
			もし待機キャンセルが×なら	
				「最終プレイ日時保存」をデバッグログへ出力する
				// 最終プレイ日時をプロファイルへ記録する
				プレイ終了日時=今
				プロファイルの最終プレイ日時=プレイ終了日時のUNIX時間
			もし終わり
		発生した場合
			[言語管理器で「InPlay.ErrorLog.TT_LastPlayDate_RecordError」を取得したもの]を「エラー」としてログ出力する
			エラーのメッセージを「エラー」としてログ出力する
		監視終わり
		
		// 総プレイ時間の記録
		例外監視
			もし待機キャンセルが×なら
				「総プレイ時間保存」をデバッグログへ出力する
				// プレイ開始日時とプレイ終了日時からプレイ時間計算してプロファイルへ記録する
				もしプレイ開始日時が無でないなら
					【プレイ時間:日時期間形式】=[プレイ開始日時]と[プレイ終了日時]の日付差
					もしプロファイルの総プレイ時間が無なら
						プロファイルの総プレイ時間=プレイ時間の合計秒数
						
					そうでなければ
						プロファイルの総プレイ時間=[プロファイルの総プレイ時間の合計秒数]+[プレイ時間の合計秒数]
						
					もし終わり
					「総プレイ時間: [プロファイルの総プレイ時間の合計秒数] 秒」をデバッグログへ出力する
				もし終わり
			もし終わり
		発生した場合
			[言語管理器で「InPlay.ErrorLog.TT_TotalPlayTime_RecordError」を取得したもの]を「エラー」としてログ出力する
			エラーのメッセージを「エラー」としてログ出力する
		監視終わり
		
		// Discord RPC の日時情報をリセットする
		例外監視
			「Discord RPC タイムスタンプリセット」をデバッグログへ出力する
			RPC管理器でタイムスタンプ削除する
		発生した場合
			[言語管理器で「InPlay.ErrorLog.TT_DiscordRPC_TimestampResetError」を取得したもの]を「エラー」としてログ出力する
			エラーのメッセージを「エラー」としてログ出力する
		監視終わり
		
		// システム情報: 一時的に無効化
		// GPUカウンターを削除する
		/*例外監視
			システム情報でGPUカウンター一覧削除する
		発生した場合
			「GPUカウンターのリセット処理でエラーが発生しました。」を「エラー」としてログ出力する
			エラーのメッセージを「エラー」としてログ出力する
		監視終わり*/
		
		システムディスプレイ解像度復元する
		
		【元ステータス番号】=ステータス番号
		
		// コンフィグファイルを復元する
		例外監視
			1としてコンフィグ復元する
		発生した場合
			[言語管理器で「InPlay.ErrorLog.ConfigFile_RestoringError」を取得したもの]を「エラー」としてログ出力する
			エラーのメッセージを「エラー」としてログ出力する
		監視終わり
		
		// プロファイルコンフィグファイルを復元する
		例外監視
			2としてコンフィグ復元する
		発生した場合
			[言語管理器で「InPlay.ErrorLog.ProfileConfigFile_RestoringError」を取得したもの]を「エラー」としてログ出力する
			エラーのメッセージを「エラー」としてログ出力する
		監視終わり
		
		// ビデオコンフィグファイルを削除する
		例外監視
			ビデオコンフィグ削除する
		発生した場合
			[言語管理器で「InPlay.ErrorLog.VideoConfigFile_SettingsRestoringError」を取得したもの]を「エラー」としてログ出力する
			エラーのメッセージを「エラー」としてログ出力する
		監視終わり
		
		// ビデオコンフィグファイルを復元する
		例外監視
			3としてコンフィグ復元する
		発生した場合
			[言語管理器で「InPlay.ErrorLog.VideoConfigFile_RestoringError」を取得したもの]を「エラー」としてログ出力する
			エラーのメッセージを「エラー」としてログ出力する
		監視終わり
		
		ステータス番号=元ステータス番号
		
		監視終了処理実行中=×
	終わり
	
	自分で監視終了後処理する手順
		// 直接プロファイルを起動した場合はアプリを終了する
		もし起動処理オプションから「ショートカット」を完全一致で探したものの個数が1以上なら
			例外監視
				アップデーターで{「直接実行」=◯}としてアップデート確認する
				メイン画面の起動中パネルの終了処理=○
				メイン画面を隠す
			発生した場合
				アプリを終了する
			監視終わり
			アプリを終了する
		もし終わり
		
		1秒待つ
		
		メイン画面の起動中パネルのプレイ処理状況=「」
		起動中パネル隠す
		
		もし監視強制終了なら
			[言語管理器で「InPlay.Dialog.Game_ProcessForciblyTerminated」を取得したもの]を「警告アイコン」で表示する
		もし終わり
		
		// ニュースの更新を開始する
		メイン画面のメインメニューパネルのニュース定期更新有効=○
	終わり
	
	自分を監視終了する手順
		監視終了処理実行する
		監視終了後処理する
	終わり
	
	【内容:文字列】を〈【レベル】として〉ログ出力する手順
		内容をレベルとしてデバッグログへ出力する
		「[[][今を「yyyy/MM/dd HH:mm:ss」に整えたもの][]] [内容]」をメイン画面の起動中パネルのログテキストへ改行して挿入する
	終わり
終わり
